gcc main.c ft_checkfile.c -Lminilibx_linux -lmlx -lX11 -lXext ./libft/libft.a -I./include

gcc test/main.c -Iminilibx_linux -Lminilibx_linux -lmlx -lX11 -lXext

make clean -C libft

/*........................*/
/* 	int i = 0;
	for(int y = 0; y < fdf.tot_riga; y++)
	{
		for(int x = 0; x < fdf.tot_colonna; x++)
		{
			printf("coords.x = %d , coords.y = %d , coords.z = %f , color = %ld\n", fdf.coords[i].x, fdf.coords[i].y, fdf.coords[i].z, fdf.coords[i].color);
			i++;
		}
	}
	fdf.mlx = mlx_init();
	fdf.mlx_win = mlx_new_window(fdf.mlx, 1920, 1080, fdf.name);
	fdf.img.img = mlx_new_image(fdf.mlx, 1920, 1080);
	fdf.img.addr = mlx_get_data_addr(fdf.img.img, &fdf.img.bits_per_pixel, &fdf.img.line_length,
									&fdf.img.endian);
	int zoom;
	if (1920 / fdf.tot_riga > 1080 / fdf.tot_colonna)
		zoom = 1080 / fdf.tot_riga;
	else
		zoom = 1920 / fdf.tot_colonna;
	zoom /= 10;
	for(int i = 0; i < fdf.tot_punti; i++)
	{
		my_mlx_pixel_put(&fdf.img, fdf.coords[i].y + (fdf.coords[i].y * zoom), fdf.coords[i].x + (fdf.coords[i].x * zoom), fdf.coords[i].color);
	}
	mlx_put_image_to_window(fdf.mlx, fdf.mlx_win, fdf.img.img, 100, 100);
	mlx_hook(fdf.mlx_win, DestroyNotify, StructureNotifyMask, ft_cool_exit, &fdf);
	mlx_loop(fdf.mlx);
	return (0); */

	/* void drawLine(t_data *data, int x0, int y0, int x1, int y1)
{
	int steep;
	float dx;
	float dy;
	float gradient;
	float xend;
	float yend;
	float xgap;
	int xpxl1;
	int ypxl1;
	float intery;
	int xpxl2;
	int ypxl2;
	int x;

	steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep)
	{
		swap(&x0, &y0);
		swap(&x1, &y1);
	}
	if (x0 > x1)
	{
		swap(&x0, &x1);
		swap(&y0, &y1);
	}

	dx = x1 - x0;
	dy = y1 - y0;
	if (dx == 0)
	{
		gradient = 1.0;
	} else
	{
		gradient = dy / dx;
	}

	xend = round(x0);
	yend = y0 + gradient * (xend - x0);
	xgap = rfpart(x0 + 0.5f);
	xpxl1 = xend;
	ypxl1 = ipart(yend);
	if (steep)
	{
		plot(data, ypxl1, xpxl1, rfpart(yend) * xgap);
		plot(data, ypxl1 + 1, xpxl1, fpart(yend) * xgap);
	} else
	{
		plot(data, xpxl1, ypxl1, rfpart(yend) * xgap);
		plot(data, xpxl1, ypxl1 + 1, fpart(yend) * xgap);
	}
	intery = yend + gradient;

	xend = round(x1);
	yend = y1 + gradient * (xend - x1);
	xgap = fpart(x1 + 0.5f);
	xpxl2 = xend;
	ypxl2 = ipart(yend);
	if (steep)
	{
		plot(data, ypxl2, xpxl2, rfpart(yend) * xgap);
		plot(data, ypxl2 + 1, xpxl2, fpart(yend) * xgap);
	} else
	{
		plot(data, xpxl2, ypxl2, rfpart(yend) * xgap);
		plot(data, xpxl2, ypxl2 + 1, fpart(yend) * xgap);
	}

	if (steep)
	{
		x = xpxl1 + 1;
		while (x < xpxl2)
		{
		    plot(data, ipart(intery), x, rfpart(intery));
		    plot(data, ipart(intery) + 1, x, fpart(intery));
			intery += gradient;
			x++;
		}
	} else
	{
		x = xpxl1 + 1;
		while (x < xpxl2)
		{
			plot(data, x, ipart(intery), rfpart(intery));
			plot(data, x, ipart(intery) + 1, fpart(intery));
			intery += gradient;
			x++;
		}
	}
}
 */

/* {
	float xend = round(x1);
	float yend = y1 + gradient * (xend - x1);
	float xgap = fpart(x1 + 0.5);
	*xpxl2 = xend;
	*ypxl2 = ipart(yend);
	if (steep)
	{
		plot(data, *ypxl2, *xpxl2, rfpart(yend) * xgap);
		plot(data, *ypxl2 + 1, *xpxl2, fpart(yend) * xgap);
	} else
	{
		plot(data, *xpxl2, *ypxl2, rfpart(yend) * xgap);
		plot(data, *xpxl2, *ypxl2 + 1, fpart(yend) * xgap);
	}
} */

/* {
	int x = xpxl1 + 1;
	while (x < xpxl2)
	{
		if (steep)
		{
			plot(data, ipart(intery), x, rfpart(intery));
			plot(data, ipart(intery) + 1, x, fpart(intery));
		} else
		{
			plot(data, x, ipart(intery), rfpart(intery));
			plot(data, x, ipart(intery) + 1, fpart(intery));
		}
		intery += gradient;
		x++;
	}
} */

/* void	drawLine(t_data *data, int x0, int y0, int x1, int y1)
{
	int steep, xpxl1, ypxl1, xpxl2, ypxl2;
	float dx, dy, gradient, xend, yend, xgap, intery;

	initializeSteepAndSwap(&steep, &x0, &y0, &x1, &y1);
	calculateGradientAndDifferences(&dx, &dy, &gradient, x0, y0, x1, y1);

	// First endpoint setup
	xend = round(x0);
	yend = y0 + gradient * (xend - x0);
	xgap = rfpart(x0 + 0.5);
	xpxl1 = xend;
	ypxl1 = ipart(yend);
	plotEndpoints(data, steep, xpxl1, ypxl1, intery, gradient, xend, yend, xgap);

	// Second endpoint setup
	drawFinalEndpoints(data, steep, &xpxl2, &ypxl2, x1, y1, gradient);

	// Main line drawing
	drawMainLine(data, xpxl1, xpxl2, yend + gradient, gradient, steep);
} */

/* {
	int steep, xpxl1, ypxl1, xpxl2, ypxl2;
	float dx, dy, gradient, xend, yend, xgap, intery;

	initializeSteepAndSwap(&steep, &x0, &y0, &x1, &y1);
	calculateGradientAndDifferences(&dx, &dy, &gradient, x0, y0, x1, y1);

	// First endpoint setup
	xend = round(x0);
	yend = y0 + gradient * (xend - x0);
	xgap = rfpart(x0 + 0.5);
	xpxl1 = xend;
	ypxl1 = ipart(yend);
	plotEndpoints(data, steep, xpxl1, ypxl1, intery, gradient, xend, yend, xgap);

	// Second endpoint setup
	drawFinalEndpoints(data, steep, &xpxl2, &ypxl2, x1, y1, gradient);

	// Main line drawing
	drawMainLine(data, xpxl1, xpxl2, yend + gradient, gradient, steep);
} */

// /* 	while (i < fdf.tot_punti)
// 	{
// 		if (i % fdf.tot_colonna != fdf.tot_colonna - 1)
// 		{
// 			ft_perror("qui\n");
// 			wu.x0 = fdf.coords[i].x * zoom  /* + DEFAULT_WIDTH / 2 */;
// 			wu.y0 = fdf.coords[i].y * zoom  /* + DEFAULT_HEIGHT / 2 */;
// 			wu.x1 = fdf.coords[i + 1].x * zoom  /* + DEFAULT_WIDTH / 2 */;
// 			wu.y1 = fdf.coords[i + 1].y * zoom  /* + DEFAULT_HEIGHT / 2 */;
// 			initializeSteepAndSwap(&wu);
// 			drawLine(&fdf.img, &wu);
// 		}
// 		if (i < fdf.tot_punti - fdf.tot_colonna)
// 		{
// 			ft_perror("qua\n");
// 			wu.x0 = fdf.coords[i].x * zoom /* + DEFAULT_WIDTH / 2 */;
// 			wu.y0 = fdf.coords[i].y * zoom /* + DEFAULT_HEIGHT / 2 */;
// 			wu.x1 = fdf.coords[i + fdf.tot_colonna].x * zoom/* + DEFAULT_WIDTH / 2 */;
// 			wu.y1 = fdf.coords[i + fdf.tot_colonna].y * zoom/* + DEFAULT_HEIGHT / 2 */;
// 			initializeSteepAndSwap(&wu);
// 			drawLine(&fdf.img, &wu);
// 		}
// 		i++;
// 	} */